{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-fc7ab217d74237589a5a0ff3bd58220a7de6abf2",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/core/BasePaymaster.sol": "project/contracts/core/BasePaymaster.sol",
    "contracts/core/EntryPointVault.sol": "project/contracts/core/EntryPointVault.sol",
    "contracts/core/ERC6909NativeVault.sol": "project/contracts/core/ERC6909NativeVault.sol",
    "contracts/core/UniversalPaymaster.sol": "project/contracts/core/UniversalPaymaster.sol",
    "contracts/interfaces/IOracle.sol": "project/contracts/interfaces/IOracle.sol",
    "contracts/PythOracleAdapter.sol": "project/contracts/PythOracleAdapter.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.5.0/",
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@4.3.1/",
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@4.3.1/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.5.0/account/utils/draft-ERC4337Utils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (account/utils/draft-ERC4337Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IEntryPoint, PackedUserOperation} from \"../../interfaces/draft-IERC4337.sol\";\nimport {Math} from \"../../utils/math/Math.sol\";\nimport {Calldata} from \"../../utils/Calldata.sol\";\nimport {Packing} from \"../../utils/Packing.sol\";\n\n/// @dev This is available on all entrypoint since v0.4.0, but is not formally part of the ERC.\ninterface IEntryPointExtra {\n    function getUserOpHash(PackedUserOperation calldata userOp) external view returns (bytes32);\n}\n\n/**\n * @dev Library with common ERC-4337 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-4337[ERC-4337].\n */\nlibrary ERC4337Utils {\n    using Packing for *;\n\n    /// @dev Address of the entrypoint v0.7.0\n    IEntryPoint internal constant ENTRYPOINT_V07 = IEntryPoint(0x0000000071727De22E5E9d8BAf0edAc6f37da032);\n\n    /// @dev Address of the entrypoint v0.8.0\n    IEntryPoint internal constant ENTRYPOINT_V08 = IEntryPoint(0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108);\n\n    /// @dev For simulation purposes, validateUserOp (and validatePaymasterUserOp) return this value on success.\n    uint256 internal constant SIG_VALIDATION_SUCCESS = 0;\n\n    /// @dev For simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value in case of signature failure, instead of revert.\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /// @dev Parses the validation data into its components. See {packValidationData}.\n    function parseValidationData(\n        uint256 validationData\n    ) internal pure returns (address aggregator, uint48 validAfter, uint48 validUntil) {\n        validAfter = uint48(bytes32(validationData).extract_32_6(0));\n        validUntil = uint48(bytes32(validationData).extract_32_6(6));\n        aggregator = address(bytes32(validationData).extract_32_20(12));\n        if (validUntil == 0) validUntil = type(uint48).max;\n    }\n\n    /// @dev Packs the validation data into a single uint256. See {parseValidationData}.\n    function packValidationData(\n        address aggregator,\n        uint48 validAfter,\n        uint48 validUntil\n    ) internal pure returns (uint256) {\n        return uint256(bytes6(validAfter).pack_6_6(bytes6(validUntil)).pack_12_20(bytes20(aggregator)));\n    }\n\n    /// @dev Same as {packValidationData}, but with a boolean signature success flag.\n    function packValidationData(bool sigSuccess, uint48 validAfter, uint48 validUntil) internal pure returns (uint256) {\n        return\n            packValidationData(\n                address(uint160(Math.ternary(sigSuccess, SIG_VALIDATION_SUCCESS, SIG_VALIDATION_FAILED))),\n                validAfter,\n                validUntil\n            );\n    }\n\n    /**\n     * @dev Combines two validation data into a single one.\n     *\n     * The `aggregator` is set to {SIG_VALIDATION_SUCCESS} if both are successful, while\n     * the `validAfter` is the maximum and the `validUntil` is the minimum of both.\n     */\n    function combineValidationData(uint256 validationData1, uint256 validationData2) internal pure returns (uint256) {\n        (address aggregator1, uint48 validAfter1, uint48 validUntil1) = parseValidationData(validationData1);\n        (address aggregator2, uint48 validAfter2, uint48 validUntil2) = parseValidationData(validationData2);\n\n        bool success = aggregator1 == address(uint160(SIG_VALIDATION_SUCCESS)) &&\n            aggregator2 == address(uint160(SIG_VALIDATION_SUCCESS));\n        uint48 validAfter = uint48(Math.max(validAfter1, validAfter2));\n        uint48 validUntil = uint48(Math.min(validUntil1, validUntil2));\n        return packValidationData(success, validAfter, validUntil);\n    }\n\n    /// @dev Returns the aggregator of the `validationData` and whether it is out of time range.\n    function getValidationData(uint256 validationData) internal view returns (address aggregator, bool outOfTimeRange) {\n        (address aggregator_, uint48 validAfter, uint48 validUntil) = parseValidationData(validationData);\n        return (aggregator_, block.timestamp < validAfter || validUntil < block.timestamp);\n    }\n\n    /// @dev Get the hash of a user operation for a given entrypoint\n    function hash(PackedUserOperation calldata self, address entrypoint) internal view returns (bytes32) {\n        // NOTE: getUserOpHash is available since v0.4.0\n        //\n        // Prior to v0.8.0, this was easy to replicate for any entrypoint and chainId. Since v0.8.0 of the\n        // entrypoint, this depends on the Entrypoint's domain separator, which cannot be hardcoded and is complex\n        // to recompute. Domain separator could be fetch using the `getDomainSeparatorV4` getter, or recomputed from\n        // the ERC-5267 getter, but both operation would require doing a view call to the entrypoint. Overall it feels\n        // simpler and less error prone to get that functionality from the entrypoint directly.\n        return IEntryPointExtra(entrypoint).getUserOpHash(self);\n    }\n\n    /// @dev Returns `factory` from the {PackedUserOperation}, or address(0) if the initCode is empty or not properly formatted.\n    function factory(PackedUserOperation calldata self) internal pure returns (address) {\n        return self.initCode.length < 20 ? address(0) : address(bytes20(self.initCode[0:20]));\n    }\n\n    /// @dev Returns `factoryData` from the {PackedUserOperation}, or empty bytes if the initCode is empty or not properly formatted.\n    function factoryData(PackedUserOperation calldata self) internal pure returns (bytes calldata) {\n        return self.initCode.length < 20 ? Calldata.emptyBytes() : self.initCode[20:];\n    }\n\n    /// @dev Returns `verificationGasLimit` from the {PackedUserOperation}.\n    function verificationGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.accountGasLimits.extract_32_16(0));\n    }\n\n    /// @dev Returns `callGasLimit` from the {PackedUserOperation}.\n    function callGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.accountGasLimits.extract_32_16(16));\n    }\n\n    /// @dev Returns the first section of `gasFees` from the {PackedUserOperation}.\n    function maxPriorityFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.gasFees.extract_32_16(0));\n    }\n\n    /// @dev Returns the second section of `gasFees` from the {PackedUserOperation}.\n    function maxFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return uint128(self.gasFees.extract_32_16(16));\n    }\n\n    /// @dev Returns the total gas price for the {PackedUserOperation} (ie. `maxFeePerGas` or `maxPriorityFeePerGas + basefee`).\n    function gasPrice(PackedUserOperation calldata self) internal view returns (uint256) {\n        unchecked {\n            // Following values are \"per gas\"\n            uint256 maxPriorityFee = maxPriorityFeePerGas(self);\n            uint256 maxFee = maxFeePerGas(self);\n            return Math.min(maxFee, maxPriorityFee + block.basefee);\n        }\n    }\n\n    /// @dev Returns the first section of `paymasterAndData` from the {PackedUserOperation}.\n    function paymaster(PackedUserOperation calldata self) internal pure returns (address) {\n        return self.paymasterAndData.length < 52 ? address(0) : address(bytes20(self.paymasterAndData[0:20]));\n    }\n\n    /// @dev Returns the second section of `paymasterAndData` from the {PackedUserOperation}.\n    function paymasterVerificationGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return self.paymasterAndData.length < 52 ? 0 : uint128(bytes16(self.paymasterAndData[20:36]));\n    }\n\n    /// @dev Returns the third section of `paymasterAndData` from the {PackedUserOperation}.\n    function paymasterPostOpGasLimit(PackedUserOperation calldata self) internal pure returns (uint256) {\n        return self.paymasterAndData.length < 52 ? 0 : uint128(bytes16(self.paymasterAndData[36:52]));\n    }\n\n    /// @dev Returns the fourth section of `paymasterAndData` from the {PackedUserOperation}.\n    function paymasterData(PackedUserOperation calldata self) internal pure returns (bytes calldata) {\n        return self.paymasterAndData.length < 52 ? Calldata.emptyBytes() : self.paymasterAndData[52:];\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/interfaces/draft-IERC4337.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC4337.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev A https://github.com/ethereum/ercs/blob/master/ERCS/erc-4337.md#useroperation[user operation] is composed of the following elements:\n * - `sender` (`address`): The account making the operation\n * - `nonce` (`uint256`): Anti-replay parameter (see “Semi-abstracted Nonce Support” )\n * - `factory` (`address`): account factory, only for new accounts\n * - `factoryData` (`bytes`): data for account factory (only if account factory exists)\n * - `callData` (`bytes`): The data to pass to the sender during the main execution call\n * - `callGasLimit` (`uint256`): The amount of gas to allocate the main execution call\n * - `verificationGasLimit` (`uint256`): The amount of gas to allocate for the verification step\n * - `preVerificationGas` (`uint256`): Extra gas to pay the bundler\n * - `maxFeePerGas` (`uint256`): Maximum fee per gas (similar to EIP-1559 max_fee_per_gas)\n * - `maxPriorityFeePerGas` (`uint256`): Maximum priority fee per gas (similar to EIP-1559 max_priority_fee_per_gas)\n * - `paymaster` (`address`): Address of paymaster contract, (or empty, if account pays for itself)\n * - `paymasterVerificationGasLimit` (`uint256`): The amount of gas to allocate for the paymaster validation code\n * - `paymasterPostOpGasLimit` (`uint256`): The amount of gas to allocate for the paymaster post-operation code\n * - `paymasterData` (`bytes`): Data for paymaster (only if paymaster exists)\n * - `signature` (`bytes`): Data passed into the account to verify authorization\n *\n * When passed to on-chain contracts, the following packed version is used.\n * - `sender` (`address`)\n * - `nonce` (`uint256`)\n * - `initCode` (`bytes`): concatenation of factory address and factoryData (or empty)\n * - `callData` (`bytes`)\n * - `accountGasLimits` (`bytes32`): concatenation of verificationGas (16 bytes) and callGas (16 bytes)\n * - `preVerificationGas` (`uint256`)\n * - `gasFees` (`bytes32`): concatenation of maxPriorityFeePerGas (16 bytes) and maxFeePerGas (16 bytes)\n * - `paymasterAndData` (`bytes`): concatenation of paymaster fields (or empty)\n * - `signature` (`bytes`)\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode; // `abi.encodePacked(factory, factoryData)`\n    bytes callData;\n    bytes32 accountGasLimits; // `abi.encodePacked(verificationGasLimit, callGasLimit)` 16 bytes each\n    uint256 preVerificationGas;\n    bytes32 gasFees; // `abi.encodePacked(maxPriorityFeePerGas, maxFeePerGas)` 16 bytes each\n    bytes paymasterAndData; // `abi.encodePacked(paymaster, paymasterVerificationGasLimit, paymasterPostOpGasLimit, paymasterData)` (20 bytes, 16 bytes, 16 bytes, dynamic)\n    bytes signature;\n}\n\n/**\n * @dev Aggregates and validates multiple signatures for a batch of user operations.\n *\n * A contract could implement this interface with custom validation schemes that allow signature aggregation,\n * enabling significant optimizations and gas savings for execution and transaction data cost.\n *\n * Bundlers and clients whitelist supported aggregators.\n *\n * See https://eips.ethereum.org/EIPS/eip-7766[ERC-7766]\n */\ninterface IAggregator {\n    /**\n     * @dev Validates the signature for a user operation.\n     * Returns an alternative signature that should be used during bundling.\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * @dev Returns an aggregated signature for a batch of user operation's signatures.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatesSignature);\n\n    /**\n     * @dev Validates that the aggregated signature is valid for the user operations.\n     *\n     * Requirements:\n     *\n     * - The aggregated signature MUST match the given list of operations.\n     */\n    function validateSignatures(PackedUserOperation[] calldata userOps, bytes calldata signature) external view;\n}\n\n/**\n * @dev Handle nonce management for accounts.\n *\n * Nonces are used in accounts as a replay protection mechanism and to ensure the order of user operations.\n * To avoid limiting the number of operations an account can perform, the interface allows using parallel\n * nonces by using a `key` parameter.\n *\n * See https://eips.ethereum.org/EIPS/eip-4337#semi-abstracted-nonce-support[ERC-4337 semi-abstracted nonce support].\n */\ninterface IEntryPointNonces {\n    /**\n     * @dev Returns the nonce for a `sender` account and a `key`.\n     *\n     * Nonces for a certain `key` are always increasing.\n     */\n    function getNonce(address sender, uint192 key) external view returns (uint256 nonce);\n}\n\n/**\n * @dev Handle stake management for entities (i.e. accounts, paymasters, factories).\n *\n * The EntryPoint must implement the following API to let entities like paymasters have a stake,\n * and thus have more flexibility in their storage access\n * (see https://eips.ethereum.org/EIPS/eip-4337#reputation-scoring-and-throttlingbanning-for-global-entities[reputation, throttling and banning.])\n */\ninterface IEntryPointStake {\n    /**\n     * @dev Returns the balance of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Deposits `msg.value` to the account.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * @dev Withdraws `withdrawAmount` from the account to `withdrawAddress`.\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\n\n    /**\n     * @dev Adds stake to the account with an unstake delay of `unstakeDelaySec`.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable;\n\n    /**\n     * @dev Unlocks the stake of the account.\n     */\n    function unlockStake() external;\n\n    /**\n     * @dev Withdraws the stake of the account to `withdrawAddress`.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n}\n\n/**\n * @dev Entry point for user operations.\n *\n * User operations are validated and executed by this contract.\n */\ninterface IEntryPoint is IEntryPointNonces, IEntryPointStake {\n    /**\n     * @dev A user operation at `opIndex` failed with `reason`.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * @dev A user operation at `opIndex` failed with `reason` and `inner` returned data.\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    /**\n     * @dev Batch of aggregated user operations per aggregator.\n     */\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        IAggregator aggregator;\n        bytes signature;\n    }\n\n    /**\n     * @dev Executes a batch of user operations.\n     * @param beneficiary Address to which gas is refunded upon completing the execution.\n     */\n    function handleOps(PackedUserOperation[] calldata ops, address payable beneficiary) external;\n\n    /**\n     * @dev Executes a batch of aggregated user operations per aggregator.\n     * @param beneficiary Address to which gas is refunded upon completing the execution.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n}\n\n/**\n * @dev Base interface for an ERC-4337 account.\n */\ninterface IAccount {\n    /**\n     * @dev Validates a user operation.\n     *\n     * * MUST validate the caller is a trusted EntryPoint\n     * * MUST validate that the signature is a valid signature of the userOpHash, and SHOULD\n     *   return SIG_VALIDATION_FAILED (and not revert) on signature mismatch. Any other error MUST revert.\n     * * MUST pay the entryPoint (caller) at least the “missingAccountFunds” (which might\n     *   be zero, in case the current account’s deposit is high enough)\n     *\n     * Returns an encoded packed validation data that is composed of the following elements:\n     *\n     * - `authorizer` (`address`): 0 for success, 1 for failure, otherwise the address of an authorizer contract\n     * - `validUntil` (`uint48`): The UserOp is valid only up to this time. Zero for “infinite”.\n     * - `validAfter` (`uint48`): The UserOp is valid only after this time.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n\n/**\n * @dev Support for executing user operations by prepending the {executeUserOp} function selector\n * to the UserOperation's `callData`.\n */\ninterface IAccountExecute {\n    /**\n     * @dev Executes a user operation.\n     */\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external;\n}\n\n/**\n * @dev Interface for a paymaster contract that agrees to pay for the gas costs of a user operation.\n *\n * NOTE: A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        opSucceeded,\n        opReverted,\n        postOpReverted\n    }\n\n    /**\n     * @dev Validates whether the paymaster is willing to pay for the user operation. See\n     * {IAccount-validateUserOp} for additional information on the return value.\n     *\n     * NOTE: Bundlers will reject this method if it modifies the state, unless it's whitelisted.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * @dev Verifies the sender is the entrypoint.\n     * @param actualGasCost the actual amount paid (by account or paymaster) for this UserOperation\n     * @param actualUserOpFeePerGas total gas used by this UserOperation (including preVerification, creation, validation and execution)\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/interfaces/IERC6909.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (interfaces/IERC6909.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-6909 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-6909[ERC].\n */\ninterface IERC6909 is IERC165 {\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set for a token of type `id`.\n     * The new allowance is `amount`.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    /**\n     * @dev Emitted when `owner` grants or revokes operator status for a `spender`.\n     */\n    event OperatorSet(address indexed owner, address indexed spender, bool approved);\n\n    /**\n     * @dev Emitted when `amount` tokens of type `id` are moved from `sender` to `receiver` initiated by `caller`.\n     */\n    event Transfer(\n        address caller,\n        address indexed sender,\n        address indexed receiver,\n        uint256 indexed id,\n        uint256 amount\n    );\n\n    /**\n     * @dev Returns the amount of tokens of type `id` owned by `owner`.\n     */\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens of type `id` that `spender` is allowed to spend on behalf of `owner`.\n     *\n     * NOTE: Does not include operator allowances.\n     */\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev Returns true if `spender` is set as an operator for `owner`.\n     */\n    function isOperator(address owner, address spender) external view returns (bool);\n\n    /**\n     * @dev Sets an approval to `spender` for `amount` of tokens of type `id` from the caller's tokens. An `amount` of\n     * `type(uint256).max` signifies an unlimited approval.\n     *\n     * Must return true.\n     */\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Grants or revokes unlimited transfer permission of any token id to `spender` for the caller's tokens.\n     *\n     * Must return true.\n     */\n    function setOperator(address spender, bool approved) external returns (bool);\n\n    /**\n     * @dev Transfers `amount` of token type `id` from the caller's account to `receiver`.\n     *\n     * Must return true.\n     */\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Transfers `amount` of token type `id` from `sender` to `receiver`.\n     *\n     * Must return true.\n     */\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n}\n\n/**\n * @dev Optional extension of {IERC6909} that adds metadata functions.\n */\ninterface IERC6909Metadata is IERC6909 {\n    /**\n     * @dev Returns the name of the token of type `id`.\n     */\n    function name(uint256 id) external view returns (string memory);\n\n    /**\n     * @dev Returns the ticker symbol of the token of type `id`.\n     */\n    function symbol(uint256 id) external view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals for the token of type `id`.\n     */\n    function decimals(uint256 id) external view returns (uint8);\n}\n\n/**\n * @dev Optional extension of {IERC6909} that adds content URI functions.\n */\ninterface IERC6909ContentURI is IERC6909 {\n    /**\n     * @dev Returns URI for the contract.\n     */\n    function contractURI() external view returns (string memory);\n\n    /**\n     * @dev Returns the URI for the token of type `id`.\n     */\n    function tokenURI(uint256 id) external view returns (string memory);\n}\n\n/**\n * @dev Optional extension of {IERC6909} that adds a token supply function.\n */\ninterface IERC6909TokenSupply is IERC6909 {\n    /**\n     * @dev Returns the total supply of the token of type `id`.\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        if (!_safeTransfer(token, to, value, true)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        if (!_safeTransferFrom(token, from, to, value, true)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _safeTransfer(token, to, value, false);\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _safeTransferFrom(token, from, to, value, false);\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        if (!_safeApprove(token, spender, value, false)) {\n            if (!_safeApprove(token, spender, 0, true)) revert SafeERC20FailedOperation(address(token));\n            if (!_safeApprove(token, spender, value, true)) revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Oppositely, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.transfer(to, value)` call, relaxing the requirement on the return value: the\n     * return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param to The recipient of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeTransfer(IERC20 token, address to, uint256 value, bool bubble) private returns (bool success) {\n        bytes4 selector = IERC20.transfer.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(to, shr(96, not(0))))\n            mstore(0x24, value)\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.transferFrom(from, to, value)` call, relaxing the requirement on the return\n     * value: the return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param from The sender of the tokens\n     * @param to The recipient of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value,\n        bool bubble\n    ) private returns (bool success) {\n        bytes4 selector = IERC20.transferFrom.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(from, shr(96, not(0))))\n            mstore(0x24, and(to, shr(96, not(0))))\n            mstore(0x44, value)\n            success := call(gas(), token, 0, 0x00, 0x64, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n            mstore(0x60, 0)\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.approve(spender, value)` call, relaxing the requirement on the return value:\n     * the return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param spender The spender of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeApprove(IERC20 token, address spender, uint256 value, bool bubble) private returns (bool success) {\n        bytes4 selector = IERC20.approve.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(spender, shr(96, not(0))))\n            mstore(0x24, value)\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/token/ERC6909/ERC6909.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC6909/ERC6909.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC6909} from \"../../interfaces/IERC6909.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of ERC-6909.\n * See https://eips.ethereum.org/EIPS/eip-6909\n */\ncontract ERC6909 is Context, ERC165, IERC6909 {\n    mapping(address owner => mapping(uint256 id => uint256)) private _balances;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    mapping(address owner => mapping(address spender => mapping(uint256 id => uint256))) private _allowances;\n\n    error ERC6909InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 id);\n    error ERC6909InsufficientAllowance(address spender, uint256 allowance, uint256 needed, uint256 id);\n    error ERC6909InvalidApprover(address approver);\n    error ERC6909InvalidReceiver(address receiver);\n    error ERC6909InvalidSender(address sender);\n    error ERC6909InvalidSpender(address spender);\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC6909\n    function balanceOf(address owner, uint256 id) public view virtual override returns (uint256) {\n        return _balances[owner][id];\n    }\n\n    /// @inheritdoc IERC6909\n    function allowance(address owner, address spender, uint256 id) public view virtual override returns (uint256) {\n        return _allowances[owner][spender][id];\n    }\n\n    /// @inheritdoc IERC6909\n    function isOperator(address owner, address spender) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][spender];\n    }\n\n    /// @inheritdoc IERC6909\n    function approve(address spender, uint256 id, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, id, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC6909\n    function setOperator(address spender, bool approved) public virtual override returns (bool) {\n        _setOperator(_msgSender(), spender, approved);\n        return true;\n    }\n\n    /// @inheritdoc IERC6909\n    function transfer(address receiver, uint256 id, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), receiver, id, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC6909\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address caller = _msgSender();\n        if (sender != caller && !isOperator(sender, caller)) {\n            _spendAllowance(sender, caller, id, amount);\n        }\n        _transfer(sender, receiver, id, amount);\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` of token `id` and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            revert ERC6909InvalidReceiver(address(0));\n        }\n        _update(address(0), to, id, amount);\n    }\n\n    /**\n     * @dev Moves `amount` of token `id` from `from` to `to` without checking for approvals. This function verifies\n     * that neither the sender nor the receiver are address(0), which means it cannot mint or burn tokens.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            revert ERC6909InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC6909InvalidReceiver(address(0));\n        }\n        _update(from, to, id, amount);\n    }\n\n    /**\n     * @dev Destroys a `amount` of token `id` from `account`.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            revert ERC6909InvalidSender(address(0));\n        }\n        _update(from, address(0), id, amount);\n    }\n\n    /**\n     * @dev Transfers `amount` of token `id` from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 id, uint256 amount) internal virtual {\n        address caller = _msgSender();\n\n        if (from != address(0)) {\n            uint256 fromBalance = _balances[from][id];\n            if (fromBalance < amount) {\n                revert ERC6909InsufficientBalance(from, fromBalance, amount, id);\n            }\n            unchecked {\n                // Overflow not possible: amount <= fromBalance.\n                _balances[from][id] = fromBalance - amount;\n            }\n        }\n        if (to != address(0)) {\n            _balances[to][id] += amount;\n        }\n\n        emit Transfer(caller, from, to, id, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`'s `id` tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to e.g. set automatic allowances for certain\n     * subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 id, uint256 amount) internal virtual {\n        if (owner == address(0)) {\n            revert ERC6909InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC6909InvalidSpender(address(0));\n        }\n        _allowances[owner][spender][id] = amount;\n        emit Approval(owner, spender, id, amount);\n    }\n\n    /**\n     * @dev Approve `spender` to operate on all of `owner`'s tokens\n     *\n     * This internal function is equivalent to `setOperator`, and can be used to e.g. set automatic allowances for\n     * certain subsystems, etc.\n     *\n     * Emits an {OperatorSet} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _setOperator(address owner, address spender, bool approved) internal virtual {\n        if (owner == address(0)) {\n            revert ERC6909InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC6909InvalidSpender(address(0));\n        }\n        _operatorApprovals[owner][spender] = approved;\n        emit OperatorSet(owner, spender, approved);\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 id, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender, id);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < amount) {\n                revert ERC6909InsufficientAllowance(spender, currentAllowance, amount, id);\n            }\n            unchecked {\n                _allowances[owner][spender][id] = currentAllowance - amount;\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/token/ERC6909/extensions/ERC6909TokenSupply.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC6909/extensions/ERC6909TokenSupply.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC6909} from \"../ERC6909.sol\";\nimport {IERC6909TokenSupply} from \"../../../interfaces/IERC6909.sol\";\n\n/**\n * @dev Implementation of the Token Supply extension defined in ERC6909.\n * Tracks the total supply of each token id individually.\n */\ncontract ERC6909TokenSupply is ERC6909, IERC6909TokenSupply {\n    mapping(uint256 id => uint256) private _totalSupplies;\n\n    /// @inheritdoc IERC6909TokenSupply\n    function totalSupply(uint256 id) public view virtual override returns (uint256) {\n        return _totalSupplies[id];\n    }\n\n    /// @dev Override the `_update` function to update the total supply of each token id as necessary.\n    function _update(address from, address to, uint256 id, uint256 amount) internal virtual override {\n        super._update(from, to, id, amount);\n\n        if (from == address(0)) {\n            _totalSupplies[id] += amount;\n        }\n        if (to == address(0)) {\n            unchecked {\n                // amount <= _balances[from][id] <= _totalSupplies[id]\n                _totalSupplies[id] -= amount;\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/Calldata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Calldata.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for manipulating objects in calldata.\n */\nlibrary Calldata {\n    // slither-disable-next-line write-after-write\n    function emptyBytes() internal pure returns (bytes calldata result) {\n        assembly (\"memory-safe\") {\n            result.offset := 0\n            result.length := 0\n        }\n    }\n\n    // slither-disable-next-line write-after-write\n    function emptyString() internal pure returns (string calldata result) {\n        assembly (\"memory-safe\") {\n            result.offset := 0\n            result.length := 0\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `condition ? a : b`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `condition ? a : b`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n\n    /**\n     * @dev Counts the number of leading zero bits in a uint256.\n     */\n    function clz(uint256 x) internal pure returns (uint256) {\n        return ternary(x == 0, 256, 255 - log2(x));\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/Packing.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Packing.sol)\n// This file was procedurally generated from scripts/generate/templates/Packing.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library packing and unpacking multiple values into bytesXX.\n *\n * Example usage:\n *\n * ```solidity\n * library MyPacker {\n *     type MyType is bytes32;\n *\n *     function _pack(address account, bytes4 selector, uint64 period) external pure returns (MyType) {\n *         bytes12 subpack = Packing.pack_4_8(selector, bytes8(period));\n *         bytes32 pack = Packing.pack_20_12(bytes20(account), subpack);\n *         return MyType.wrap(pack);\n *     }\n *\n *     function _unpack(MyType self) external pure returns (address, bytes4, uint64) {\n *         bytes32 pack = MyType.unwrap(self);\n *         return (\n *             address(Packing.extract_32_20(pack, 0)),\n *             Packing.extract_32_4(pack, 20),\n *             uint64(Packing.extract_32_8(pack, 24))\n *         );\n *     }\n * }\n * ```\n *\n * _Available since v5.1._\n */\n// solhint-disable func-name-mixedcase\nlibrary Packing {\n    error OutOfRangeAccess();\n\n    function pack_1_1(bytes1 left, bytes1 right) internal pure returns (bytes2 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(248, not(0)))\n            right := and(right, shl(248, not(0)))\n            result := or(left, shr(8, right))\n        }\n    }\n\n    function pack_2_2(bytes2 left, bytes2 right) internal pure returns (bytes4 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_4(bytes2 left, bytes4 right) internal pure returns (bytes6 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_6(bytes2 left, bytes6 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_8(bytes2 left, bytes8 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_10(bytes2 left, bytes10 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_20(bytes2 left, bytes20 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_2_22(bytes2 left, bytes22 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }\n\n    function pack_4_2(bytes4 left, bytes2 right) internal pure returns (bytes6 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_4(bytes4 left, bytes4 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_6(bytes4 left, bytes6 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_8(bytes4 left, bytes8 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_12(bytes4 left, bytes12 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_16(bytes4 left, bytes16 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_20(bytes4 left, bytes20 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_24(bytes4 left, bytes24 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(64, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_4_28(bytes4 left, bytes28 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(32, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }\n\n    function pack_6_2(bytes6 left, bytes2 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_4(bytes6 left, bytes4 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_6(bytes6 left, bytes6 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_10(bytes6 left, bytes10 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_16(bytes6 left, bytes16 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_6_22(bytes6 left, bytes22 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }\n\n    function pack_8_2(bytes8 left, bytes2 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_4(bytes8 left, bytes4 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_8(bytes8 left, bytes8 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_12(bytes8 left, bytes12 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_16(bytes8 left, bytes16 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_20(bytes8 left, bytes20 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_8_24(bytes8 left, bytes24 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(64, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }\n\n    function pack_10_2(bytes10 left, bytes2 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_6(bytes10 left, bytes6 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_10(bytes10 left, bytes10 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_12(bytes10 left, bytes12 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_10_22(bytes10 left, bytes22 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }\n\n    function pack_12_4(bytes12 left, bytes4 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_8(bytes12 left, bytes8 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_10(bytes12 left, bytes10 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_12(bytes12 left, bytes12 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_16(bytes12 left, bytes16 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_12_20(bytes12 left, bytes20 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }\n\n    function pack_16_4(bytes16 left, bytes4 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_6(bytes16 left, bytes6 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_8(bytes16 left, bytes8 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_12(bytes16 left, bytes12 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_16_16(bytes16 left, bytes16 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }\n\n    function pack_20_2(bytes20 left, bytes2 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_20_4(bytes20 left, bytes4 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_20_8(bytes20 left, bytes8 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_20_12(bytes20 left, bytes12 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }\n\n    function pack_22_2(bytes22 left, bytes2 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }\n\n    function pack_22_6(bytes22 left, bytes6 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }\n\n    function pack_22_10(bytes22 left, bytes10 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }\n\n    function pack_24_4(bytes24 left, bytes4 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(64, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(192, right))\n        }\n    }\n\n    function pack_24_8(bytes24 left, bytes8 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(64, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(192, right))\n        }\n    }\n\n    function pack_28_4(bytes28 left, bytes4 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(32, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(224, right))\n        }\n    }\n\n    function extract_2_1(bytes2 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 1) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_2_1(bytes2 self, bytes1 value, uint8 offset) internal pure returns (bytes2 result) {\n        bytes1 oldValue = extract_2_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_4_1(bytes4 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 3) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_4_1(bytes4 self, bytes1 value, uint8 offset) internal pure returns (bytes4 result) {\n        bytes1 oldValue = extract_4_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_4_2(bytes4 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_4_2(bytes4 self, bytes2 value, uint8 offset) internal pure returns (bytes4 result) {\n        bytes2 oldValue = extract_4_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_6_1(bytes6 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 5) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_6_1(bytes6 self, bytes1 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes1 oldValue = extract_6_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_6_2(bytes6 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_6_2(bytes6 self, bytes2 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes2 oldValue = extract_6_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_6_4(bytes6 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_6_4(bytes6 self, bytes4 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes4 oldValue = extract_6_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_1(bytes8 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 7) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_8_1(bytes8 self, bytes1 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes1 oldValue = extract_8_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_2(bytes8 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_8_2(bytes8 self, bytes2 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes2 oldValue = extract_8_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_4(bytes8 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_8_4(bytes8 self, bytes4 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes4 oldValue = extract_8_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_8_6(bytes8 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_8_6(bytes8 self, bytes6 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes6 oldValue = extract_8_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_1(bytes10 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 9) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_10_1(bytes10 self, bytes1 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes1 oldValue = extract_10_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_2(bytes10 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_10_2(bytes10 self, bytes2 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes2 oldValue = extract_10_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_4(bytes10 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_10_4(bytes10 self, bytes4 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes4 oldValue = extract_10_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_6(bytes10 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_10_6(bytes10 self, bytes6 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes6 oldValue = extract_10_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_10_8(bytes10 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_10_8(bytes10 self, bytes8 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes8 oldValue = extract_10_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_1(bytes12 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 11) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_12_1(bytes12 self, bytes1 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes1 oldValue = extract_12_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_2(bytes12 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_12_2(bytes12 self, bytes2 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes2 oldValue = extract_12_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_4(bytes12 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_12_4(bytes12 self, bytes4 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes4 oldValue = extract_12_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_6(bytes12 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_12_6(bytes12 self, bytes6 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes6 oldValue = extract_12_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_8(bytes12 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_12_8(bytes12 self, bytes8 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes8 oldValue = extract_12_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_12_10(bytes12 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_12_10(bytes12 self, bytes10 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes10 oldValue = extract_12_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_1(bytes16 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 15) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_16_1(bytes16 self, bytes1 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes1 oldValue = extract_16_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_2(bytes16 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_16_2(bytes16 self, bytes2 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes2 oldValue = extract_16_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_4(bytes16 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_16_4(bytes16 self, bytes4 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes4 oldValue = extract_16_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_6(bytes16 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_16_6(bytes16 self, bytes6 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes6 oldValue = extract_16_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_8(bytes16 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_16_8(bytes16 self, bytes8 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes8 oldValue = extract_16_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_10(bytes16 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_16_10(bytes16 self, bytes10 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes10 oldValue = extract_16_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_16_12(bytes16 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_16_12(bytes16 self, bytes12 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes12 oldValue = extract_16_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_1(bytes20 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 19) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_20_1(bytes20 self, bytes1 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes1 oldValue = extract_20_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_2(bytes20 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_20_2(bytes20 self, bytes2 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes2 oldValue = extract_20_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_4(bytes20 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_20_4(bytes20 self, bytes4 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes4 oldValue = extract_20_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_6(bytes20 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_20_6(bytes20 self, bytes6 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes6 oldValue = extract_20_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_8(bytes20 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_20_8(bytes20 self, bytes8 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes8 oldValue = extract_20_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_10(bytes20 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_20_10(bytes20 self, bytes10 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes10 oldValue = extract_20_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_12(bytes20 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_20_12(bytes20 self, bytes12 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes12 oldValue = extract_20_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_20_16(bytes20 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_20_16(bytes20 self, bytes16 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes16 oldValue = extract_20_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_1(bytes22 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 21) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_22_1(bytes22 self, bytes1 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes1 oldValue = extract_22_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_2(bytes22 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_22_2(bytes22 self, bytes2 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes2 oldValue = extract_22_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_4(bytes22 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_22_4(bytes22 self, bytes4 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes4 oldValue = extract_22_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_6(bytes22 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_22_6(bytes22 self, bytes6 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes6 oldValue = extract_22_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_8(bytes22 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_22_8(bytes22 self, bytes8 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes8 oldValue = extract_22_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_10(bytes22 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_22_10(bytes22 self, bytes10 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes10 oldValue = extract_22_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_12(bytes22 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_22_12(bytes22 self, bytes12 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes12 oldValue = extract_22_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_16(bytes22 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_22_16(bytes22 self, bytes16 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes16 oldValue = extract_22_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_22_20(bytes22 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_22_20(bytes22 self, bytes20 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes20 oldValue = extract_22_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_1(bytes24 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 23) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_24_1(bytes24 self, bytes1 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes1 oldValue = extract_24_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_2(bytes24 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_24_2(bytes24 self, bytes2 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes2 oldValue = extract_24_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_4(bytes24 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_24_4(bytes24 self, bytes4 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes4 oldValue = extract_24_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_6(bytes24 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_24_6(bytes24 self, bytes6 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes6 oldValue = extract_24_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_8(bytes24 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_24_8(bytes24 self, bytes8 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes8 oldValue = extract_24_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_10(bytes24 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_24_10(bytes24 self, bytes10 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes10 oldValue = extract_24_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_12(bytes24 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_24_12(bytes24 self, bytes12 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes12 oldValue = extract_24_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_16(bytes24 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_24_16(bytes24 self, bytes16 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes16 oldValue = extract_24_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_20(bytes24 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_24_20(bytes24 self, bytes20 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes20 oldValue = extract_24_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_24_22(bytes24 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }\n\n    function replace_24_22(bytes24 self, bytes22 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes22 oldValue = extract_24_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_1(bytes28 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 27) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_28_1(bytes28 self, bytes1 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes1 oldValue = extract_28_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_2(bytes28 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 26) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_28_2(bytes28 self, bytes2 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes2 oldValue = extract_28_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_4(bytes28 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 24) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_28_4(bytes28 self, bytes4 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes4 oldValue = extract_28_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_6(bytes28 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_28_6(bytes28 self, bytes6 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes6 oldValue = extract_28_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_8(bytes28 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_28_8(bytes28 self, bytes8 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes8 oldValue = extract_28_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_10(bytes28 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_28_10(bytes28 self, bytes10 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes10 oldValue = extract_28_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_12(bytes28 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_28_12(bytes28 self, bytes12 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes12 oldValue = extract_28_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_16(bytes28 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_28_16(bytes28 self, bytes16 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes16 oldValue = extract_28_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_20(bytes28 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_28_20(bytes28 self, bytes20 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes20 oldValue = extract_28_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_22(bytes28 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }\n\n    function replace_28_22(bytes28 self, bytes22 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes22 oldValue = extract_28_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_28_24(bytes28 self, uint8 offset) internal pure returns (bytes24 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(64, not(0)))\n        }\n    }\n\n    function replace_28_24(bytes28 self, bytes24 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes24 oldValue = extract_28_24(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(64, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_1(bytes32 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 31) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }\n\n    function replace_32_1(bytes32 self, bytes1 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes1 oldValue = extract_32_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_2(bytes32 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 30) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }\n\n    function replace_32_2(bytes32 self, bytes2 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes2 oldValue = extract_32_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_4(bytes32 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 28) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }\n\n    function replace_32_4(bytes32 self, bytes4 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes4 oldValue = extract_32_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_6(bytes32 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 26) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }\n\n    function replace_32_6(bytes32 self, bytes6 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes6 oldValue = extract_32_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_8(bytes32 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 24) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }\n\n    function replace_32_8(bytes32 self, bytes8 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes8 oldValue = extract_32_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_10(bytes32 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }\n\n    function replace_32_10(bytes32 self, bytes10 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes10 oldValue = extract_32_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_12(bytes32 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }\n\n    function replace_32_12(bytes32 self, bytes12 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes12 oldValue = extract_32_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_16(bytes32 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }\n\n    function replace_32_16(bytes32 self, bytes16 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes16 oldValue = extract_32_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_20(bytes32 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }\n\n    function replace_32_20(bytes32 self, bytes20 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes20 oldValue = extract_32_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_22(bytes32 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }\n\n    function replace_32_22(bytes32 self, bytes22 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes22 oldValue = extract_32_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_24(bytes32 self, uint8 offset) internal pure returns (bytes24 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(64, not(0)))\n        }\n    }\n\n    function replace_32_24(bytes32 self, bytes24 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes24 oldValue = extract_32_24(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(64, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n\n    function extract_32_28(bytes32 self, uint8 offset) internal pure returns (bytes28 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(32, not(0)))\n        }\n    }\n\n    function replace_32_28(bytes32 self, bytes28 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes28 oldValue = extract_32_28(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(32, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.5.0/utils/Panic.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.3.1/IPyth.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Returns the required fee to update a TWAP price.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getTwapUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method will not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime,` but choose to store price updates if `storeUpdatesIfFresh`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// This method will eventually allow the caller to determine whether parsed price feeds should update\n    /// the stored values as well.\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minAllowedPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxAllowedPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @param storeUpdatesIfFresh flag for the parse function to\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesWithConfig(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minAllowedPublishTime,\n        uint64 maxAllowedPublishTime,\n        bool checkUniqueness,\n        bool checkUpdateDataIsMinimal,\n        bool storeUpdatesIfFresh\n    )\n        external\n        payable\n        returns (\n            PythStructs.PriceFeed[] memory priceFeeds,\n            uint64[] memory slots\n        );\n\n    /// @notice Parse time-weighted average price (TWAP) from two consecutive price updates for the given `priceIds`.\n    ///\n    /// This method calculates TWAP between two data points by processing the difference in cumulative price values\n    /// divided by the time period. It requires exactly two updates that contain valid price information\n    /// for all the requested price IDs.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the updateData array.\n    ///\n    /// @dev Reverts if:\n    /// - The transferred fee is not sufficient\n    /// - The updateData is invalid or malformed\n    /// - The updateData array does not contain exactly 2 updates\n    /// - There is no update for any of the given `priceIds`\n    /// - The time ordering between data points is invalid (start time must be before end time)\n    /// @param updateData Array containing exactly two price updates (start and end points for TWAP calculation)\n    /// @param priceIds Array of price ids to calculate TWAP for\n    /// @return twapPriceFeeds Array of TWAP price feeds corresponding to the given `priceIds` (with the same order)\n    function parseTwapPriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds\n    )\n        external\n        payable\n        returns (PythStructs.TwapPriceFeed[] memory twapPriceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.3.1/IPythEvents.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when the TWAP price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param startTime Start time of the TWAP.\n    /// @param endTime End time of the TWAP.\n    /// @param twapPrice Price of the TWAP.\n    /// @param twapConf Confidence interval of the TWAP.\n    /// @param downSlotsRatio Down slot ratio of the TWAP.\n    event TwapPriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 startTime,\n        uint64 endTime,\n        int64 twapPrice,\n        uint64 twapConf,\n        uint32 downSlotsRatio\n    );\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.3.1/PythStructs.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n\n    struct TwapPriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Start time of the TWAP\n        uint64 startTime;\n        // End time of the TWAP\n        uint64 endTime;\n        // TWAP price\n        Price twap;\n        // Down slot ratio represents the ratio of price feed updates that were missed or unavailable\n        // during the TWAP period, expressed as a fixed-point number between 0 and 1e6 (100%).\n        // For example:\n        //   - 0 means all price updates were available\n        //   - 500_000 means 50% of updates were missed\n        //   - 1_000_000 means all updates were missed\n        // This can be used to assess the quality/reliability of the TWAP calculation.\n        // Applications should define a maximum acceptable ratio (e.g. 100000 for 10%)\n        // and revert if downSlotsRatio exceeds it.\n        uint32 downSlotsRatio;\n    }\n\n    // Information used to calculate time-weighted average prices (TWAP)\n    struct TwapPriceInfo {\n        // slot 1\n        int128 cumulativePrice;\n        uint128 cumulativeConf;\n        // slot 2\n        uint64 numDownSlots;\n        uint64 publishSlot;\n        uint64 publishTime;\n        uint64 prevPublishTime;\n        // slot 3\n        int32 expo;\n    }\n}\n"
      },
      "project/contracts/core/BasePaymaster.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.28;\n\nimport {ERC4337Utils} from \"@openzeppelin/contracts/account/utils/draft-ERC4337Utils.sol\";\nimport {IEntryPoint, IPaymaster, PackedUserOperation} from \"@openzeppelin/contracts/interfaces/draft-IERC4337.sol\";\n\n/**\n * @dev Minimal paymaster base contract implementing the ERC-4337 paymaster interface. Provides core validation\n * and post-operation logic that must be extended by concrete implementations.\n */\nabstract contract BasePaymaster is IPaymaster {\n    /* @dev Unauthorized call to the paymaster. */\n    error PaymasterUnauthorized(address sender);\n\n    /* @dev Revert if the caller is not the entry point. */\n    modifier onlyEntryPoint() {\n        _checkEntryPoint();\n        _;\n    }\n\n    /* @dev Returns the canonical ERC-4337 entry point contract that validates user operations. */\n    function entryPoint() public view virtual returns (IEntryPoint) {\n        return ERC4337Utils.ENTRYPOINT_V08;\n    }\n\n    /* @inheritdoc IPaymaster */\n    function validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n        public\n        virtual\n        onlyEntryPoint\n        returns (bytes memory context, uint256 validationData)\n    {\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n\n    /* @inheritdoc IPaymaster */\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost, uint256 actualUserOpFeePerGas)\n        public\n        virtual\n        onlyEntryPoint\n    {\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\n    }\n\n    /**\n     * @dev Internal validation logic to determine if the paymaster will sponsor the user operation.\n     * Implementations must return context data for {_postOp} and validation data encoding approval or rejection.\n     *\n     * NOTE: The `requiredPreFund` is the amount the paymaster must prefund in native tokens, calculated as\n     * `requiredGas * userOp.maxFeePerGas`, where required gas includes verificationGasLimit + callGasLimit +\n     * paymasterVerificationGasLimit + paymasterPostOpGasLimit + preVerificationGas.\n     *\n     * @param userOp The user operation being validated.\n     * @param userOpHash The hash of the user operation.\n     * @param requiredPreFund The amount of native tokens required to be prefunded.\n     * @return context Data to be passed to {_postOp} for post-execution logic.\n     * @return validationData Encoded validation result (0 for success, 1 for failure, or timeRange encoding).\n     */\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash, uint256 requiredPreFund)\n        internal\n        virtual\n        returns (bytes memory context, uint256 validationData);\n\n    /**\n     * @dev Hook called after the user operation executes, receiving the context from {_validatePaymasterUserOp}.\n     * Only invoked if validation returned non-empty context. Override to implement refund logic or state updates.\n     *\n     * NOTE: The `actualUserOpFeePerGas` is not equivalent to `tx.gasprice` because user operations can be bundled\n     * with other transactions, causing the effective gas price to differ from the transaction's gas price.\n     *\n     * @param mode Indicates whether the user operation succeeded, reverted, or was a prefund-only operation.\n     * @param context The context bytes returned from {_validatePaymasterUserOp}.\n     * @param actualGasCost The actual gas cost paid by the paymaster in native tokens.\n     * @param actualUserOpFeePerGas The effective gas price used for this specific user operation.\n     */\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost, uint256 actualUserOpFeePerGas)\n        internal\n        virtual {}\n\n    /* @dev Reverts if the caller is not the {entryPoint}. Used by the {onlyEntryPoint} modifier. */\n    function _checkEntryPoint() internal view virtual {\n        if (msg.sender != address(entryPoint())) {\n            revert PaymasterUnauthorized(msg.sender);\n        }\n    }\n}\n"
      },
      "project/contracts/core/EntryPointVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.28;\n\nimport {ERC6909NativeVault} from \"./ERC6909NativeVault.sol\";\nimport {IEntryPoint} from \"@openzeppelin/contracts/interfaces/draft-IERC4337.sol\";\n\nabstract contract EntryPointVault is ERC6909NativeVault {\n    /* @dev Returns the entry point contract instance. */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /* deposits to the entry point and mints ERC-6909 shares*/\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares, uint256 id) internal override {\n        super._deposit(caller, receiver, assets, shares, id);\n        entryPoint().depositTo{value: assets}(address(this));\n    }\n\n    /* withdraws from the entry point and burn ERC-6909 shares*/\n    function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares, uint256 id)\n        internal\n        override\n    {\n        super._withdraw(caller, receiver, owner, assets, shares, id);\n        entryPoint().withdrawTo(payable(receiver), assets);\n    }\n}\n"
      },
      "project/contracts/core/ERC6909NativeVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {ERC6909TokenSupply} from \"@openzeppelin/contracts/token/ERC6909/extensions/ERC6909TokenSupply.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nabstract contract ERC6909NativeVault is ERC6909TokenSupply {\n    using Math for uint256;\n\n    /* @dev Total amount of ETH for a particular ID token. */\n    mapping(uint256 id => uint256) private _assets;\n\n    event Deposit(address indexed caller, address indexed receiver, uint256 assets, uint256 shares, uint256 id);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares,\n        uint256 id\n    );\n\n    error ERC6909NativeVaultExceededMaxDeposit(address receiver, uint256 assets, uint256 max, uint256 id);\n\n    error ERC6909NativeVaultExceededMaxMint(address receiver, uint256 shares, uint256 max, uint256 id);\n\n    error ERC6909NativeVaultExceededMaxWithdraw(address owner, uint256 assets, uint256 max, uint256 id);\n\n    error ERC6909NativeVaultExceededMaxRedeem(address owner, uint256 shares, uint256 max, uint256 id);\n\n    error ERC6909NativeVaultInvalidNativeAmount(uint256 assets, uint256 value);\n\n    error ERC6909NativeVaultWithdrawFailed(address receiver, uint256 assets);\n\n    /* @dev Returns the total amount of ETH assets for a particular token ID pool. */\n    function totalAssets(uint256 id) public view virtual returns (uint256) {\n        return _assets[id];\n    }\n\n    function maxDeposit(\n        address,\n        /* receiver */\n        uint256 /* id */\n    )\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return type(uint256).max;\n    }\n\n    function maxMint(\n        address,\n        /* receiver */\n        uint256 /* id */\n    )\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner, uint256 id) public view virtual returns (uint256) {\n        return previewRedeem(maxRedeem(owner, id), id);\n    }\n\n    function maxRedeem(address owner, uint256 id) public view virtual returns (uint256) {\n        return balanceOf(owner, id);\n    }\n\n    function previewDeposit(uint256 assets, uint256 id) public view virtual returns (uint256) {\n        return _convertToShares(assets, id, Math.Rounding.Floor);\n    }\n\n    function previewMint(uint256 shares, uint256 id) public view virtual returns (uint256) {\n        return _convertToAssets(shares, id, Math.Rounding.Ceil);\n    }\n\n    function previewWithdraw(uint256 assets, uint256 id) public view virtual returns (uint256) {\n        return _convertToShares(assets, id, Math.Rounding.Ceil);\n    }\n\n    function previewRedeem(uint256 shares, uint256 id) public view virtual returns (uint256) {\n        return _convertToAssets(shares, id, Math.Rounding.Floor);\n    }\n\n    /* deposits ETH into the vault and mints ERC-6909 shares */\n    function deposit(uint256 assets, address receiver, uint256 id) public payable virtual returns (uint256) {\n        if (assets != msg.value) {\n            revert ERC6909NativeVaultInvalidNativeAmount(assets, msg.value);\n        }\n\n        uint256 maxAssets = maxDeposit(receiver, id);\n        if (assets > maxAssets) {\n            revert ERC6909NativeVaultExceededMaxDeposit(receiver, assets, maxAssets, id);\n        }\n\n        uint256 shares = previewDeposit(assets, id);\n        _deposit(_msgSender(), receiver, assets, shares, id);\n\n        return shares;\n    }\n\n    /* withdraws ETH from the vault and burns ERC-6909 shares */\n    function withdraw(uint256 assets, address receiver, address owner, uint256 id) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner, id);\n        if (assets > maxAssets) {\n            revert ERC6909NativeVaultExceededMaxWithdraw(owner, assets, maxAssets, id);\n        }\n\n        uint256 shares = previewWithdraw(assets, id);\n        _withdraw(_msgSender(), receiver, owner, assets, shares, id);\n\n        return shares;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * NOTE: Uses virtual shares (1 wei) to mitigate inflation attacks on empty pools.\n     */\n    function _convertToShares(uint256 assets, uint256 id, Math.Rounding rounding)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return assets.mulDiv(totalSupply(id) + 1, totalAssets(id) + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     *\n     * NOTE: Uses virtual shares (1 wei) to mitigate inflation attacks on empty pools.\n     */\n    function _convertToAssets(uint256 shares, uint256 id, Math.Rounding rounding)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return shares.mulDiv(totalAssets(id) + 1, totalSupply(id) + 1, rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     *\n     * NOTE: ETH is already received via `msg.value` in `deposit`, so we only need to track it.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares, uint256 id) internal virtual {\n        _increaseAssets(id, assets);\n        _mint(receiver, id, shares);\n\n        emit Deposit(caller, receiver, assets, shares, id);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     *\n     * IMPORTANT: this function should be overridden and extended to send ETH to the receiver.\n     */\n    function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares, uint256 id)\n        internal\n        virtual\n    {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, id, shares);\n        }\n\n        _burn(owner, id, shares);\n        _decreaseAssets(id, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares, id);\n    }\n\n    /* increases the total amount of ETH assets for a particular token ID pool */\n    function _increaseAssets(uint256 id, uint256 amount) internal virtual {\n        _assets[id] += amount;\n    }\n\n    /* decreases the total amount of ETH assets for a particular token ID pool */\n    function _decreaseAssets(uint256 id, uint256 amount) internal virtual {\n        _assets[id] -= amount;\n    }\n}\n"
      },
      "project/contracts/core/UniversalPaymaster.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.28;\n\n// External\nimport {ERC4337Utils, PackedUserOperation} from \"@openzeppelin/contracts/account/utils/draft-ERC4337Utils.sol\";\nimport {IEntryPoint} from \"@openzeppelin/contracts/interfaces/draft-IERC4337.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n// Internal\nimport {BasePaymaster} from \"./BasePaymaster.sol\";\nimport {EntryPointVault} from \"./EntryPointVault.sol\";\nimport {IOracle} from \"../interfaces/IOracle.sol\";\nimport {PythOracleAdapter} from \"../PythOracleAdapter.sol\";\n\n/// @title UniversalPaymaster\n/// @notice A trustless paymaster that allows users to pay for gas with any token.\ncontract UniversalPaymaster is BasePaymaster, EntryPointVault, PythOracleAdapter {\n    using ERC4337Utils for PackedUserOperation;\n    using SafeERC20 for IERC20;\n    using Math for *;\n\n    struct Pool {\n        // the token address that the pool accepts as gas payment\n        address token;\n        // the Pyth token feed ID that provides the token price\n        bytes32 tokenFeedId;\n        // the pool LP fee expressed in basis points (bps)\n        // i.e: 100 bps = 1%\n        uint24 lpFeeBps;\n        // the pool rebalancing fee expressed in basis points (bps)\n        // i.e: 100 bps = 1%\n        //\n        // @TODO: the pool fee should be a relationship between the token reserves and the eth reserves.\n        // A kind of bounding curve must be implemented where:\n        // When ethReserves are zero, the fee is maximum (e.g 2%)\n        // When tokenReserves are zero, the fee is minimum (e.g 0%)\n        uint24 rebalancingFeeBps;\n    }\n\n    // emitted when a new pool is initialized\n    event PoolInitialized(address token, bytes32 tokenFeedId, uint24 lpFeeBps, uint24 rebalancingFeeBps);\n\n    // emitted when a pool is rebalanced\n    event PoolRebalanced(address token, uint256 ethAmount, uint256 tokenAmount);\n\n    // thrown when a pool is already initialized\n    error PoolAlreadyInitialized(address token);\n\n    // thrown when a pool is not initialized\n    error PoolNotInitialized(address token);\n\n    // thrown when a pool does not have enough eth reserves\n    error PoolNotEnoughEthReserves(uint256 ethRequired);\n\n    // thrown when a pool does not have enough token reserves\n    error PoolNotEnoughTokenReserves(uint256 tokensRequired);\n\n    // thrown when an invalid oracle is provided\n    error InvalidOracle(address oracle);\n\n    // thrown when an invalid pool fee configuration is provided\n    error InvalidPoolFeeBps(uint24 lpFeeBps, uint24 rebalancingFeeBps);\n\n    // thrown when not enough eth is sent\n    error NotEnoughEthSent(uint256 ethSent, uint256 ethRequired);\n\n    // thrown when an invalid amount is provided\n    error InvalidAmount(uint256 amount);\n\n    // registry of initialized `pool` for a given `token`\n    mapping(address token => Pool pool) public pools;\n\n    // constructs the `UniversalPaymaster` contract by initializing the `PythOracleAdapter`\n    // @param _pyth The address of the Pyth contract\n    // @param _ethFeedId The ID of the ETH/USD price feed\n    constructor(address _pyth, bytes32 _ethFeedId) PythOracleAdapter(_pyth, _ethFeedId) {}\n\n    // initializes a new pool for a given `token`, `lpFeeBps`, `rebalancingFeeBps` and `tokenFeedId`\n    // NOTE: In the current version, only one pool can be initialized for a given `token`.\n    // @TODO: allow multiple pools for a given `token` with different `lpFeeBps` and `rebalancingFeeBps`.\n    // So that different liquidity providers can compete to offer the best pricing.\n    function initializePool(address token, uint24 lpFeeBps, uint24 rebalancingFeeBps, bytes32 tokenFeedId) public {\n        require(pools[token].tokenFeedId == bytes32(0), PoolAlreadyInitialized(token));\n        require(tokenFeedId != bytes32(0), InvalidTokenFeedId(tokenFeedId));\n        require(\n            lpFeeBps >= 0 && rebalancingFeeBps >= 0 && lpFeeBps + rebalancingFeeBps <= 10000,\n            InvalidPoolFeeBps(lpFeeBps, rebalancingFeeBps)\n        );\n\n        pools[token].token = token;\n        pools[token].tokenFeedId = tokenFeedId;\n        pools[token].lpFeeBps = lpFeeBps;\n        pools[token].rebalancingFeeBps = rebalancingFeeBps;\n\n        emit PoolInitialized(token, tokenFeedId, lpFeeBps, rebalancingFeeBps);\n    }\n\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32, uint256 maxCost)\n        internal\n        virtual\n        override\n        returns (bytes memory context, uint256 validationData)\n    {\n        // decode the token and price update data from paymaster data\n        (address token, bytes[] memory priceUpdateData) = abi.decode(userOp.paymasterData(), (address, bytes[]));\n\n        // verify the pool is initialized\n        Pool memory pool = pools[token];\n        require(pool.tokenFeedId != bytes32(0), PoolNotInitialized(token));\n\n        // verify the pool has enough eth reserves to cover the gas cost\n        require(getPoolEthReserves(token) >= maxCost, PoolNotEnoughEthReserves(maxCost));\n\n        // query the token price from oracle (using cached/stale price for prefund estimation)\n        uint256 tokenPriceInEth = getTokenPriceInEth(pool.tokenFeedId);\n\n        // query the fees in basis points for the token pool\n        uint24 feesBps = pool.lpFeeBps + pool.rebalancingFeeBps;\n\n        // calculate the prefund amount (conservative estimate)\n        uint256 gasCost = _gasCost(maxCost, userOp.maxFeePerGas());\n        uint256 prefund = _erc20Cost(gasCost, tokenPriceInEth, feesBps);\n\n        // attempt to make the user to pay the prefund amount to this paymaster\n        bool prefunded = IERC20(token).trySafeTransferFrom(userOp.sender, address(this), prefund);\n\n        // if the prefund payment failed, fail the validation\n        if (!prefunded) return (bytes(\"\"), ERC4337Utils.SIG_VALIDATION_FAILED);\n\n        // encode the context for the `postOp` function including price update data\n        context = abi.encode(userOp.sender, token, tokenPriceInEth, feesBps, prefund, priceUpdateData);\n\n        return (context, validationData);\n    }\n\n    function _postOp(PostOpMode, bytes calldata context, uint256 actualGasCost, uint256 actualUserOpFeePerGas)\n        internal\n        virtual\n        override\n    {\n        // decode the context for the `postOp` function\n        (\n            address sender,\n            address token,\n            uint256 tokenPriceInEth,\n            uint256 feesBps,\n            uint256 prefund,\n            bytes[] memory priceUpdateData\n        ) = abi.decode(context, (address, address, uint256, uint256, uint256, bytes[]));\n\n        // Update the on-chain prices with fresh data\n        uint256 updateFee = pyth.getUpdateFee(priceUpdateData);\n        pyth.updatePriceFeeds{value: updateFee}(priceUpdateData);\n\n        // convert from gas amount to token amount using FRESH price\n        uint256 actualGasCostInEth = _gasCost(actualGasCost, actualUserOpFeePerGas);\n        uint256 actualTokenAmount = _erc20Cost(actualGasCostInEth, tokenPriceInEth, feesBps);\n\n        // transfer the excess token amount to the user\n        uint256 excessTokenAmount = prefund - actualTokenAmount;\n        if (excessTokenAmount > 0) IERC20(token).safeTransfer(sender, excessTokenAmount);\n\n        // track the gas spent in the token pool\n        // @TODO: there is a potential issue here that must be improved:\n        // We are approximating `actualGasCostInEth` by approximating `postOpCost`, which is unknown at this point in runtime,\n        // and therefore the deltaError may unsynchonize the assets of the token pool, by making the paymaster think this\n        // userOp decreased the deposited eth by more or less than it did, messing accountability by small deltas at a time.\n        _decreaseAssets(uint256(uint160(token)), actualGasCostInEth);\n    }\n\n    /// @dev Calculates the cost of the user operation in tokens.\n    /// @param gasCost The cost of the user operation in ETH (wei).\n    /// @param tokenPrice The price of the token in ETH (wei per 1e18 token units).\n    /// @param feesBps The fees in basis points. i.e 100bps = 1%\n    /// @return erc20CostWithFees The cost of the user operation in token base units, including fees.\n    /// NOTE: If 1 token costs 0.0004 ETH, tokenPrice = 4e14 wei per 1e18 token units.\n    /// To get tokens needed: tokens = gasCost * 1e18 / tokenPrice\n    function _erc20Cost(uint256 gasCost, uint256 tokenPrice, uint256 feesBps)\n        internal\n        view\n        virtual\n        returns (uint256 erc20CostWithFees)\n    {\n        uint256 baseErc20Cost = gasCost.mulDiv(_tokenPriceDenominator(), tokenPrice);\n        erc20CostWithFees = baseErc20Cost + (baseErc20Cost * feesBps / 10000);\n    }\n\n    function _gasCost(uint256 cost, uint256 feePerGas) internal view virtual returns (uint256 gasCost) {\n        return (cost + _postOpCost() * feePerGas);\n    }\n\n    /// @dev Denominator used for interpreting the `tokenPrice` returned by {_fetchDetails}\n    // as \"fixed point\" in {_erc20Cost}.\n    function _tokenPriceDenominator() internal view virtual returns (uint256) {\n        return 1e18;\n    }\n\n    /// @dev Over-estimates the cost of the post-operation logic\n    function _postOpCost() internal pure returns (uint256) {\n        return 23_947;\n    }\n\n    // allows any permissionless `rebalancer` to rebalance the pool by buying tokens with eth\n    // at a discount price of `rebalancingFeeBps` basis points, an economic incentive paid by\n    // the users to the rebalancers to keep the pools balanced and healthy.\n    function rebalance(address token, uint256 tokenAmount, address receiver)\n        public\n        payable\n        returns (uint256 ethAmountAfterDiscount)\n    {\n        require(tokenAmount > 0, InvalidAmount(tokenAmount));\n\n        // get the oracle token feed id and validate the pool exists\n        Pool memory pool = pools[token];\n        require(pool.tokenFeedId != bytes32(0), PoolNotInitialized(token));\n\n        // validate the pool has enough tokenAmount to sell\n        require(getPoolTokenReserves(token) >= tokenAmount, PoolNotEnoughTokenReserves(tokenAmount));\n\n        // query the token price from oracle\n        uint256 tokenPriceInEth = getTokenPriceInEth(pool.tokenFeedId);\n\n        // calculate the required eth amount for buying the token amount\n        uint256 ethAmount = tokenAmount * tokenPriceInEth / 1e18;\n\n        // calculate the eth amount after the rebalancing discount\n        ethAmountAfterDiscount = ethAmount - (ethAmount * pool.rebalancingFeeBps / 10000);\n\n        // validate the msg.value amount is enough to cover the eth amount after the rebalancing discount\n        require(msg.value >= ethAmountAfterDiscount, NotEnoughEthSent(msg.value, ethAmountAfterDiscount));\n\n        // track the eth added to the pool for the shares accountability\n        _increaseAssets(uint256(uint160(token)), ethAmountAfterDiscount);\n\n        // put the eth into the entrypoint\n        entryPoint().depositTo{value: ethAmountAfterDiscount}(address(this));\n\n        // send the bought tokens to the receiver\n        IERC20(token).safeTransfer(receiver, tokenAmount);\n\n        // send back any excess eth to the rebalancer\n        uint256 excessEth = msg.value - ethAmountAfterDiscount;\n        if (excessEth > 0) payable(msg.sender).transfer(excessEth);\n\n        emit PoolRebalanced(token, ethAmountAfterDiscount, tokenAmount);\n    }\n\n    // returns the current eth reserves for a given token pool\n    function getPoolEthReserves(address token) public view returns (uint256 ethReserves) {\n        return totalAssets(uint256(uint160(token)));\n    }\n\n    // returns the current token reserves for a given token pool\n    function getPoolTokenReserves(address token) public view returns (uint256 tokenReserves) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    // required override by Solidity\n    // returns the entryPoint defined by the `BasePaymaster` contract.\n    function entryPoint() public view virtual override(BasePaymaster, EntryPointVault) returns (IEntryPoint) {\n        return super.entryPoint();\n    }\n}\n"
      },
      "project/contracts/interfaces/IOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/// @title IOracle\n/// @notice Interface for the Oracle contract\ninterface IOracle {\n    /// @notice Returns the price of the token in ETH\n    /// @param tokenFeedId The Pyth token feed ID of the token to get the price of\n    /// @return priceInEth The price of the token in ETH\n    function getTokenPriceInEth(bytes32 tokenFeedId) external view returns (uint256 priceInEth);\n}\n"
      },
      "project/contracts/PythOracleAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport {IOracle} from \"./interfaces/IOracle.sol\";\n\n/// @title PythOracle\n/// @dev Oracle adapter that converts Pyth USD-denominated feeds to TOKEN/ETH prices.\n/// NOTE: This is a view-only adapter that reads cached prices. Prices must be updated\n/// via updatePriceFeeds() before reading for fresh data.\ncontract PythOracleAdapter is IOracle {\n    IPyth public immutable pyth;\n\n    /// @dev Pyth price feed ID for ETH/USD\n    bytes32 public immutable ethFeedId;\n\n    error InvalidTokenFeedId(bytes32 tokenFeedId);\n\n    error InvalidPrice(bytes32 tokenFeedId);\n\n    constructor(address _pyth, bytes32 _ethFeedId) {\n        pyth = IPyth(_pyth);\n        ethFeedId = _ethFeedId;\n    }\n\n    /// @dev Returns the price of a token in ETH (wei per token).\n    /// WARNING: This reads cached prices. For fresh prices, call pyth.updatePriceFeeds() first.\n    function getTokenPriceInEth(bytes32 tokenFeedId) public view returns (uint256 priceInEth) {\n        require(tokenFeedId != bytes32(0), InvalidTokenFeedId(tokenFeedId));\n\n        // Get TOKEN/USD and ETH/USD prices (uses cached data)\n        PythStructs.Price memory tokenUsd = pyth.getPriceUnsafe(tokenFeedId);\n        PythStructs.Price memory ethUsd = pyth.getPriceUnsafe(ethFeedId);\n\n        require(tokenUsd.price > 0 && ethUsd.price > 0, InvalidPrice(tokenFeedId));\n\n        // Calculate TOKEN/ETH = TOKEN/USD ÷ ETH/USD\n        // Both prices are in USD, so division gives us TOKEN/ETH ratio\n        // We need to handle the exponents properly\n        return _calculateRatio(tokenUsd, ethUsd);\n    }\n\n    /// @dev Calculates TOKEN/ETH price normalized to 1e18 (wei per token)\n    /// @param tokenUsd The TOKEN/USD price from Pyth\n    /// @param ethUsd The ETH/USD price from Pyth\n    /// @return ratio The TOKEN/ETH price in wei (1e18 = 1 ETH per token)\n    function _calculateRatio(PythStructs.Price memory tokenUsd, PythStructs.Price memory ethUsd)\n        internal\n        pure\n        returns (uint256 ratio)\n    {\n        // Convert prices to uint256 for safe math\n        uint256 tokenPrice = uint256(uint64(tokenUsd.price));\n        uint256 ethPrice = uint256(uint64(ethUsd.price));\n\n        // Calculate the combined exponent difference\n        // We want result in 1e18 scale (wei)\n        // ratio = (tokenPrice / ethPrice) * 10^(tokenExpo - ethExpo + 18)\n        int32 exponentDiff = tokenUsd.expo - ethUsd.expo;\n\n        // Base ratio\n        uint256 baseRatio = (tokenPrice * 1e18) / ethPrice;\n\n        // Apply exponent adjustment\n        if (exponentDiff == 0) {\n            return baseRatio;\n        } else if (exponentDiff > 0) {\n            // Token has larger exponent, multiply\n            return baseRatio * (10 ** uint32(exponentDiff));\n        } else {\n            // Token has smaller exponent, divide\n            return baseRatio / (10 ** uint32(-exponentDiff));\n        }\n    }\n}\n"
      }
    }
  }
}